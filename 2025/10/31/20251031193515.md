# Commit: 9f751725e96d26b5a15550492dc87b30b709725e
## Message: remove unneccessary checks for Android M
## Changed files:
app/src/main/java/lineageos/weather/LineageWeatherManager.java

app/src/main/java/nodomain/freeyourgadget/gadgetbridge/GBApplication.java

app/src/main/java/nodomain/freeyourgadget/gadgetbridge/activities/DevicesFragment.java

app/src/main/java/nodomain/freeyourgadget/gadgetbridge/externalevents/notifications/GoogleMapsNotificationHandler.java

app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/huami/zeppos/services/ZeppOsCannedMessagesService.java

app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/xiaomi/services/XiaomiNotificationService.java

## Diff:
```
diff --git a/app/src/main/java/lineageos/weather/LineageWeatherManager.java b/app/src/main/java/lineageos/weather/LineageWeatherManager.java
index 48c767dcec..abcbb42f65 100644
--- a/app/src/main/java/lineageos/weather/LineageWeatherManager.java
+++ b/app/src/main/java/lineageos/weather/LineageWeatherManager.java
@@ -44,7 +44,6 @@ import lineageos.providers.WeatherContract;
 /**
  * Provides access to the weather services in the device.
  */
-@RequiresApi(api = Build.VERSION_CODES.M)
 public class LineageWeatherManager {
 
     private static ILineageWeatherManager sWeatherManagerService;
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/GBApplication.java b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/GBApplication.java
index 489f7c9702..92c64f5a29 100644
--- a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/GBApplication.java
+++ b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/GBApplication.java
@@ -572,7 +572,6 @@ public class GBApplication extends Application {
         }
     }
 
-    @TargetApi(Build.VERSION_CODES.M)
     public static boolean isPriorityNumber(int priorityType, String number) {
         NotificationManager.Policy notificationPolicy = notificationManager.getNotificationPolicy();
         if (priorityType == Policy.PRIORITY_CATEGORY_MESSAGES) {
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/activities/DevicesFragment.java b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/activities/DevicesFragment.java
index ae3531b8d8..78b3bde613 100644
--- a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/activities/DevicesFragment.java
+++ b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/activities/DevicesFragment.java
@@ -189,7 +189,7 @@ public class DevicesFragment extends Fragment {
 
         refreshPairedDevices();
 
-        if (GB.isBluetoothEnabled() && deviceList.isEmpty() && Build.VERSION.SDK_INT < Build.VERSION_CODES.M) {
+        if (GB.isBluetoothEnabled() && deviceList.isEmpty()) {
             startActivity(new Intent(getActivity(), DiscoveryActivityV2.class));
         }
 
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/externalevents/notifications/GoogleMapsNotificationHandler.java b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/externalevents/notifications/GoogleMapsNotificationHandler.java
index 9a50712777..cbc321c12f 100644
--- a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/externalevents/notifications/GoogleMapsNotificationHandler.java
+++ b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/externalevents/notifications/GoogleMapsNotificationHandler.java
@@ -1202,51 +1202,49 @@ public class GoogleMapsNotificationHandler {
             LOG.info("Navigation: " + instruction + "," + distance + "," + navLines[0] + "," + navLines[1] + "," + navLines[2]);
             int matchedIcon = -1;
             // getLargeIcon only works in API 23+ - don't try and get icons on older devices
-            if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M) {
-                Icon icon = notification.getLargeIcon();
-                if (icon != null) {
-                    // We convert the icon to a bitmap, then to x 32x32 1bpp which we'll check against known images
-                    Drawable drawable = icon.loadDrawable(context);
-                    Bitmap bitmap = Bitmap.createBitmap(32, 32, Bitmap.Config.ARGB_8888); // Single color bitmap will be created of 1x1 pixel
-                    Canvas canvas = new Canvas(bitmap);
-                    drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());
-                    drawable.draw(canvas);
-                    int[] pixelsRGBA = new int[32 * 32];
-                    bitmap.getPixels(pixelsRGBA, 0, 32, 0, 0, 32, 32);
-                    int[] pixelPack = new int[32]; // pixels packed down 1bpp
-                    char[] pixelStringChars = new char[33 * 32];
+            Icon icon = notification.getLargeIcon();
+            if (icon != null) {
+                // We convert the icon to a bitmap, then to x 32x32 1bpp which we'll check against known images
+                Drawable drawable = icon.loadDrawable(context);
+                Bitmap bitmap = Bitmap.createBitmap(32, 32, Bitmap.Config.ARGB_8888); // Single color bitmap will be created of 1x1 pixel
+                Canvas canvas = new Canvas(bitmap);
+                drawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());
+                drawable.draw(canvas);
+                int[] pixelsRGBA = new int[32 * 32];
+                bitmap.getPixels(pixelsRGBA, 0, 32, 0, 0, 32, 32);
+                int[] pixelPack = new int[32]; // pixels packed down 1bpp
+                char[] pixelStringChars = new char[33 * 32];
 
-                    for (int y = 0; y < 32; y++) {
-                        int pack = 0;
-                        for (int x = 0; x < 32; x++) {
-                            int pixel = ((pixelsRGBA[(y * 32) + x] & 0x80000000) != 0) ? 1 : 0;
-                            pack = (pack << 1) | pixel; // check top bit (=alpha)
-                            pixelStringChars[x + y * 33] = (pixel != 0) ? '1' : '0';
-                        }
-                        pixelStringChars[32 + y * 33] = '\n';
-                        pixelPack[y] = pack;
+                for (int y = 0; y < 32; y++) {
+                    int pack = 0;
+                    for (int x = 0; x < 32; x++) {
+                        int pixel = ((pixelsRGBA[(y * 32) + x] & 0x80000000) != 0) ? 1 : 0;
+                        pack = (pack << 1) | pixel; // check top bit (=alpha)
+                        pixelStringChars[x + y * 33] = (pixel != 0) ? '1' : '0';
                     }
-                    // This is now a printable string showing the image, which we can log if we don't recognise it
-                    String pixelString = new String(pixelStringChars);
+                    pixelStringChars[32 + y * 33] = '\n';
+                    pixelPack[y] = pack;
+                }
+                // This is now a printable string showing the image, which we can log if we don't recognise it
+                String pixelString = new String(pixelStringChars);
 
-                    int bestDiff = 100;
-                    for (int i = 0; i < knownImages.size(); i++) {
-                        IconType knownImage = knownImages.get(i);
-                        int diff = 0;
-                        // Work out how many bits differ over the whole image
-                        for (int j = 0; j < 32; j++)
-                            diff += Integer.bitCount(knownImage.icon[j] ^ pixelPack[j]);
-                        // if it's close enough, match
-                        if (diff < 32 && diff < bestDiff) {
-                            matchedIcon = knownImage.iconType;
-                            bestDiff = diff;
-                        }
-                    }
-                    if (matchedIcon < 0) {
-                        LOG.info("Icon NEW:\n" + pixelString);
-                        knownImages.add(new IconType(255, pixelPack));
+                int bestDiff = 100;
+                for (int i = 0; i < knownImages.size(); i++) {
+                    IconType knownImage = knownImages.get(i);
+                    int diff = 0;
+                    // Work out how many bits differ over the whole image
+                    for (int j = 0; j < 32; j++)
+                        diff += Integer.bitCount(knownImage.icon[j] ^ pixelPack[j]);
+                    // if it's close enough, match
+                    if (diff < 32 && diff < bestDiff) {
+                        matchedIcon = knownImage.iconType;
+                        bestDiff = diff;
                     }
                 }
+                if (matchedIcon < 0) {
+                    LOG.info("Icon NEW:\n" + pixelString);
+                    knownImages.add(new IconType(255, pixelPack));
+                }
             }
             NavigationInfoSpec navInfo = new NavigationInfoSpec();
             if (matchedIcon>=0)
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/huami/zeppos/services/ZeppOsCannedMessagesService.java b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/huami/zeppos/services/ZeppOsCannedMessagesService.java
index e921f7b2bb..98bffce27c 100644
--- a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/huami/zeppos/services/ZeppOsCannedMessagesService.java
+++ b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/huami/zeppos/services/ZeppOsCannedMessagesService.java
@@ -86,11 +86,7 @@ public class ZeppOsCannedMessagesService extends AbstractZeppOsService {
                 LOG.info("Canned Message reply SMS check");
                 final boolean canSendSms;
                 // TODO place this behind a setting as well?
-                if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M) {
-                    canSendSms = getContext().checkSelfPermission(Manifest.permission.SEND_SMS) == PackageManager.PERMISSION_GRANTED;
-                } else {
-                    canSendSms = true;
-                }
+                canSendSms = getContext().checkSelfPermission(Manifest.permission.SEND_SMS) == PackageManager.PERMISSION_GRANTED;
                 sendCannedSmsReplyAllow(canSendSms);
                 return;
             default:
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/xiaomi/services/XiaomiNotificationService.java b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/xiaomi/services/XiaomiNotificationService.java
index 90724f7e29..c1ccb24460 100644
--- a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/xiaomi/services/XiaomiNotificationService.java
+++ b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/xiaomi/services/XiaomiNotificationService.java
@@ -434,11 +434,7 @@ public class XiaomiNotificationService extends AbstractXiaomiService implements
     }
 
     public boolean canSendSms() {
-        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M) {
-            return getSupport().getContext().checkSelfPermission(Manifest.permission.SEND_SMS) == PackageManager.PERMISSION_GRANTED;
-        } else {
-            return true;
-        }
+        return getSupport().getContext().checkSelfPermission(Manifest.permission.SEND_SMS) == PackageManager.PERMISSION_GRANTED;
     }
 
     private void handleNotificationIconQuery(final XiaomiProto.NotificationIconPackage notificationIconPackage) {
```
-----------------------------------
