# Commit: 94aba43151b5aa30148d1957c04b210deb264486
## Message: Fix pairing of unsupported devices
## Changed files:
app/src/main/java/nodomain/freeyourgadget/gadgetbridge/activities/discovery/DiscoveryActivityV2.java

app/src/main/java/nodomain/freeyourgadget/gadgetbridge/activities/discovery/GBScanEventProcessor.java

app/src/main/java/nodomain/freeyourgadget/gadgetbridge/impl/GBDeviceCandidate.java

app/src/main/java/nodomain/freeyourgadget/gadgetbridge/util/DeviceHelper.java

## Diff:
```
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/activities/discovery/DiscoveryActivityV2.java b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/activities/discovery/DiscoveryActivityV2.java
index 12aaf21b97..2ebc3bf2a5 100644
--- a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/activities/discovery/DiscoveryActivityV2.java
+++ b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/activities/discovery/DiscoveryActivityV2.java
@@ -25,7 +25,6 @@ import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothManager;
 import android.bluetooth.le.BluetoothLeScanner;
 import android.bluetooth.le.ScanCallback;
-import android.bluetooth.le.ScanFilter;
 import android.bluetooth.le.ScanRecord;
 import android.bluetooth.le.ScanResult;
 import android.bluetooth.le.ScanSettings;
@@ -65,7 +64,6 @@ import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.annotation.RequiresApi;
 import androidx.annotation.RequiresPermission;
-import androidx.annotation.StringRes;
 import androidx.core.app.ActivityCompat;
 import androidx.core.content.ContextCompat;
 import androidx.core.view.MenuProvider;
@@ -210,7 +208,7 @@ public class DiscoveryActivityV2 extends AbstractGBActivity implements AdapterVi
                             return;
                         }
                         final GBDeviceCandidate deviceCandidate = data.getParcelableExtra(AuthKeyActivity.EXTRA_DEVICE_CANDIDATE_RESULT);
-                        final DeviceType deviceType = DeviceHelper.getInstance().resolveDeviceType(deviceCandidate);
+                        final DeviceType deviceType = DeviceHelper.getInstance().resolveDeviceType(Objects.requireNonNull(deviceCandidate));
                         startPair(deviceCandidate, deviceType.getDeviceCoordinator());
                     }
                 });
@@ -305,6 +303,8 @@ public class DiscoveryActivityV2 extends AbstractGBActivity implements AdapterVi
         LOG.info("Starting discovery");
         startButton.setText(getString(R.string.discovery_stop_scanning));
 
+        DeviceHelper.getInstance().clearForcedDeviceTypes();
+
         deviceFoundProcessor.clear();
         deviceFoundProcessor.start();
 
@@ -316,7 +316,7 @@ public class DiscoveryActivityV2 extends AbstractGBActivity implements AdapterVi
             final Set<BluetoothDevice> pairedDevices = BluetoothAdapter.getDefaultAdapter().getBondedDevices();
             for (final BluetoothDevice device : pairedDevices) {
                 try {
-                    final Method isConnectedMethod = device.getClass().getMethod("isConnected");
+                    @SuppressWarnings("JavaReflectionMemberAccess") final Method isConnectedMethod = device.getClass().getMethod("isConnected");
                     final Boolean isConnected = (Boolean) isConnectedMethod.invoke(device);
                     if (isConnected != null && isConnected) {
                         LOG.debug("Pre-adding already bonded device {}", device.getAddress());
@@ -530,28 +530,12 @@ public class DiscoveryActivityV2 extends AbstractGBActivity implements AdapterVi
         return builder.build();
     }
 
-    private List<ScanFilter> getScanFilters() {
-        final List<ScanFilter> allFilters = new ArrayList<>();
-        for (DeviceType deviceType : DeviceType.values()) {
-            allFilters.addAll(deviceType.getDeviceCoordinator().createBLEScanFilters());
-        }
-        return allFilters;
-    }
-
     private Message getPostMessage(final Runnable runnable) {
         final Message message = Message.obtain(handler, runnable);
         message.obj = runnable;
         return message;
     }
 
-    private void showWarnDialog(@StringRes final int message) {
-        new MaterialAlertDialogBuilder(getContext())
-                .setMessage(message)
-                .setPositiveButton(R.string.ok, (dialog, whichButton) -> {
-                })
-                .show();
-    }
-
     private void checkAndRequestLocationPermission() {
         /* This is more or less a copy of what's in ControlCenterv2, but
         we do this in case the permissions weren't requested since there
@@ -566,7 +550,7 @@ public class DiscoveryActivityV2 extends AbstractGBActivity implements AdapterVi
             wantedPermissions.add(Manifest.permission.ACCESS_FINE_LOCATION);
         }
         // if we need location permissions, request both together to avoid a bunch of dialogs
-        if (wantedPermissions.size() > 0) {
+        if (!wantedPermissions.isEmpty()) {
             toast(DiscoveryActivityV2.this, getString(R.string.error_no_location_access), Toast.LENGTH_SHORT, GB.ERROR);
             ActivityCompat.requestPermissions(this, wantedPermissions.toArray(new String[0]), 0);
             wantedPermissions.clear();
@@ -592,13 +576,14 @@ public class DiscoveryActivityV2 extends AbstractGBActivity implements AdapterVi
                 wantedPermissions.add(Manifest.permission.BLUETOOTH_CONNECT);
             }
         }
-        if (wantedPermissions.size() > 0) {
+        if (!wantedPermissions.isEmpty()) {
             GB.toast(this, getString(R.string.permission_granting_mandatory), Toast.LENGTH_LONG, GB.ERROR);
             if (Build.VERSION.SDK_INT < Build.VERSION_CODES.S) {
                 ActivityCompat.requestPermissions(this, wantedPermissions.toArray(new String[0]), 0);
             } else {
                 ActivityResultLauncher<String[]> requestMultiplePermissionsLauncher =
                         registerForActivityResult(new ActivityResultContracts.RequestMultiplePermissions(), isGranted -> {
+                            //noinspection StatementWithEmptyBody
                             if (!isGranted.containsValue(false)) {
                                 // Permission is granted. Continue the action or workflow in your app.
                                 // should we do startDiscovery here??
@@ -637,11 +622,14 @@ public class DiscoveryActivityV2 extends AbstractGBActivity implements AdapterVi
             return;
         }
 
+        // Normal click - clear all potential forced devices
+        DeviceHelper.getInstance().clearForcedDeviceTypes();
+
         preparePair(deviceCandidate);
     }
 
     private void preparePair(final GBDeviceCandidate deviceCandidate) {
-        DeviceType deviceType = DeviceHelper.getInstance().resolveDeviceType(deviceCandidate);
+        final DeviceType deviceType = DeviceHelper.getInstance().resolveDeviceType(deviceCandidate);
 
         if (!deviceType.isSupported()) {
             LOG.warn("Unsupported device candidate {}", deviceCandidate);
@@ -838,7 +826,7 @@ public class DiscoveryActivityV2 extends AbstractGBActivity implements AdapterVi
                 .setPositiveButton(R.string.ok, (dialog, which) -> {
                     if (selectedUnsupportedDeviceKey != DebugActivity.SELECT_DEVICE) {
                         final DeviceType deviceType = DeviceType.values()[(int) selectedUnsupportedDeviceKey];
-                        deviceCandidate.setForcedType(deviceType);
+                        DeviceHelper.getInstance().setForcedDeviceType(deviceCandidate.getMacAddress().toLowerCase(), deviceType);
                         preparePair(deviceCandidate);
                     }
                 })
@@ -988,7 +976,7 @@ public class DiscoveryActivityV2 extends AbstractGBActivity implements AdapterVi
                     return;
                 }
                 ParcelUuid[] uuids = null;
-                SparseArray<byte[]> manufacturerSpecificData = null;
+                SparseArray<byte[]> manufacturerSpecificData;
                 final List<ParcelUuid> serviceUuids = scanRecord.getServiceUuids();
                 if (serviceUuids != null) {
                     uuids = serviceUuids.toArray(new ParcelUuid[0]);
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/activities/discovery/GBScanEventProcessor.java b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/activities/discovery/GBScanEventProcessor.java
index c000a6f16a..4153c8cc21 100644
--- a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/activities/discovery/GBScanEventProcessor.java
+++ b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/activities/discovery/GBScanEventProcessor.java
@@ -173,10 +173,8 @@ public final class GBScanEventProcessor implements Runnable {
         LOG.debug("found device: {}, {}", candidate.getName(), candidate.getMacAddress());
         if (LOG.isDebugEnabled()) {
             final ParcelUuid[] uuids = candidate.getServiceUuids();
-            if (uuids != null && uuids.length > 0) {
-                for (ParcelUuid uuid : uuids) {
-                    LOG.debug("  supports uuid: {}", uuid.toString());
-                }
+            for (ParcelUuid uuid : uuids) {
+                LOG.debug("  supports uuid: {}", uuid.toString());
             }
         }
 
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/impl/GBDeviceCandidate.java b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/impl/GBDeviceCandidate.java
index 66652ced1d..cf986518e1 100644
--- a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/impl/GBDeviceCandidate.java
+++ b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/impl/GBDeviceCandidate.java
@@ -38,7 +38,6 @@ import java.util.UUID;
 
 import nodomain.freeyourgadget.gadgetbridge.GBApplication;
 import nodomain.freeyourgadget.gadgetbridge.R;
-import nodomain.freeyourgadget.gadgetbridge.model.DeviceType;
 import nodomain.freeyourgadget.gadgetbridge.util.AndroidUtils;
 
 /**
@@ -56,11 +55,6 @@ public class GBDeviceCandidate implements Parcelable, Cloneable {
     private String deviceName;
     private Boolean isBonded = null;
 
-    /**
-     * If set, forces this candidate to be recognized as a specific device type.
-     */
-    private DeviceType forcedType;
-
     private SparseArray<byte[]> manufacturerSpecificData;
 
     public GBDeviceCandidate(BluetoothDevice device, short rssi, ParcelUuid[] serviceUuids,
@@ -82,10 +76,6 @@ public class GBDeviceCandidate implements Parcelable, Cloneable {
         serviceUuids = AndroidUtils.toParcelUuids(in.readParcelableArray(getClass().getClassLoader()));
 
         deviceName = in.readString();
-        final String forcedTypeName = in.readString();
-        if (forcedTypeName != null && !forcedTypeName.isEmpty()) {
-            forcedType = DeviceType.valueOf(forcedTypeName);
-        }
         final int isBondedInt = in.readInt();
         if (isBondedInt != -1) {
             isBonded = (isBondedInt == 1);
@@ -100,7 +90,6 @@ public class GBDeviceCandidate implements Parcelable, Cloneable {
         dest.writeInt(rssi);
         dest.writeParcelableArray(serviceUuids, 0);
         dest.writeString(deviceName);
-        dest.writeString(forcedType != null ? forcedType.name() : "");
         if (isBonded == null) {
             dest.writeInt(-1);
         } else {
@@ -130,14 +119,6 @@ public class GBDeviceCandidate implements Parcelable, Cloneable {
         return device != null ? device.getAddress() : GBApplication.getContext().getString(R.string._unknown_);
     }
 
-    public DeviceType getForcedType() {
-        return forcedType;
-    }
-
-    public void setForcedType(final DeviceType forcedType) {
-        this.forcedType = forcedType;
-    }
-
     private ParcelUuid[] mergeServiceUuids(ParcelUuid[] serviceUuids, ParcelUuid[] deviceUuids) {
         Set<ParcelUuid> uuids = new LinkedHashSet<>();
         if (serviceUuids != null) {
@@ -294,7 +275,6 @@ public class GBDeviceCandidate implements Parcelable, Cloneable {
             clone.serviceUuids = this.serviceUuids;
             clone.deviceName = this.deviceName;
             clone.isBonded = this.isBonded;
-            clone.forcedType = this.forcedType;
             clone.manufacturerSpecificData = this.manufacturerSpecificData;
             return clone;
         } catch (final CloneNotSupportedException e) {
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/util/DeviceHelper.java b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/util/DeviceHelper.java
index 16b7e405f6..8d4d952b1e 100644
--- a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/util/DeviceHelper.java
+++ b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/util/DeviceHelper.java
@@ -46,6 +46,8 @@ import java.util.Comparator;
 import java.util.HashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Locale;
+import java.util.Map;
 import java.util.Set;
 
 import nodomain.freeyourgadget.gadgetbridge.GBApplication;
@@ -63,6 +65,13 @@ public class DeviceHelper {
 
     private static final DeviceHelper instance = new DeviceHelper();
 
+    /**
+     * A map from mac address to a forced device type this device will be recognized as. Allows unsupported
+     * devices to be paired as a specified device type. This is a hack, required until we refactor the current
+     * discovery and pairing process.
+     */
+    private final Map<String, DeviceType> forcedDeviceTypes = new HashMap<>();
+
     private DeviceType[] orderedDeviceTypes = null;
 
     public static DeviceHelper getInstance() {
@@ -86,11 +95,9 @@ public class DeviceHelper {
      * Returns the list of all available devices that are supported by Gadgetbridge.
      * Note that no state is known about the returned devices. Even if one of those
      * devices is connected, it will report the default not-connected state.
-     *
+     * <p>
      * Clients interested in the "live" devices being managed should use the class
      * DeviceManager.
-     * @param context
-     * @return
      */
     public Set<GBDevice> getAvailableDevices(Context context) {
         BluetoothAdapter btAdapter = BluetoothAdapter.getDefaultAdapter();
@@ -101,9 +108,23 @@ public class DeviceHelper {
             GB.toast(context, context.getString(R.string.bluetooth_is_disabled_), Toast.LENGTH_SHORT, GB.WARN);
         }
 
-        Set<GBDevice> availableDevices = new LinkedHashSet<>(getDatabaseDevices());
-        Prefs prefs = GBApplication.getPrefs();
-        return availableDevices;
+        return new LinkedHashSet<>(getDatabaseDevices());
+    }
+
+    public void setForcedDeviceType(final String address, final DeviceType deviceType) {
+        LOG.debug("Forcing recognition of {} as {}", address, deviceType);
+        synchronized (this) {
+            forcedDeviceTypes.put(address.toLowerCase(), deviceType);
+        }
+    }
+
+    public void clearForcedDeviceTypes() {
+        synchronized (this) {
+            if (!forcedDeviceTypes.isEmpty()) {
+                LOG.debug("Clearing forced device types");
+            }
+            forcedDeviceTypes.clear();
+        }
     }
 
     @RequiresPermission(Manifest.permission.BLUETOOTH_CONNECT)
@@ -118,8 +139,8 @@ public class DeviceHelper {
         return resolvedType.getDeviceCoordinator().createDevice(candidate, resolvedType);
     }
 
-    private DeviceType[] getOrderedDeviceTypes(){
-        if(orderedDeviceTypes == null){
+    private DeviceType[] getOrderedDeviceTypes() {
+        if (orderedDeviceTypes == null) {
             ArrayList<DeviceType> orderedDevices = new ArrayList<>(Arrays.asList(DeviceType.values()));
             Collections.sort(orderedDevices, Comparator.comparingInt(dc -> dc.getDeviceCoordinator().getOrderPriority()));
             orderedDeviceTypes = orderedDevices.toArray(new DeviceType[0]);
@@ -127,20 +148,24 @@ public class DeviceHelper {
 
         return orderedDeviceTypes;
     }
+
     public DeviceType resolveDeviceType(@NonNull final GBDeviceCandidate deviceCandidate) {
         return resolveDeviceType(deviceCandidate, true);
     }
 
-    public DeviceType resolveDeviceType(@NonNull final GBDeviceCandidate deviceCandidate, boolean useCache){
-        final DeviceType forcedType = deviceCandidate.getForcedType();
-        if (forcedType != null) {
-            return forcedType;
-        }
-
+    public DeviceType resolveDeviceType(@NonNull final GBDeviceCandidate deviceCandidate, boolean useCache) {
         synchronized (this) {
+            final String macAddress = deviceCandidate.getMacAddress().toLowerCase();
+
+            if (forcedDeviceTypes.containsKey(macAddress)) {
+                final DeviceType deviceType = forcedDeviceTypes.get(macAddress);
+                LOG.debug("Resolving of {} is forced to {}", macAddress, deviceType);
+                return deviceType;
+            }
+
             if (useCache) {
                 DeviceType cachedType =
-                        deviceTypeCache.get(deviceCandidate.getMacAddress().toLowerCase());
+                        deviceTypeCache.get(macAddress);
                 if (cachedType != null) {
                     return cachedType;
                 }
@@ -148,11 +173,11 @@ public class DeviceHelper {
 
             for (DeviceType type : getOrderedDeviceTypes()) {
                 if (type.getDeviceCoordinator().supports(deviceCandidate)) {
-                    deviceTypeCache.put(deviceCandidate.getMacAddress().toLowerCase(), type);
+                    deviceTypeCache.put(macAddress, type);
                     return type;
                 }
             }
-            deviceTypeCache.put(deviceCandidate.getMacAddress().toLowerCase(), DeviceType.UNKNOWN);
+            deviceTypeCache.put(macAddress, DeviceType.UNKNOWN);
         }
         return DeviceType.UNKNOWN;
     }
@@ -182,8 +207,6 @@ public class DeviceHelper {
     /**
      * Converts a known device from the database to a GBDevice.
      * Note: The device might not be supported anymore, so callers should verify that.
-     * @param dbDevice
-     * @return
      */
     public GBDevice toGBDevice(Device dbDevice) {
         DeviceType deviceType = DeviceType.fromName(dbDevice.getTypeName());
```
-----------------------------------
