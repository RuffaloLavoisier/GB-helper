# Commit: c79f1da98af6942b32e9216e9b91888592291c03
## Message: Roidmi: Switch to BTBR support class
## Changed files:
app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/RoidmiIoThread.java

app/src/main/java/nodomain/freeyourgadget/gadgetbridge/devices/roidmi/RoidmiConst.java

app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/Roidmi1Protocol.java

app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/Roidmi3Protocol.java

app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/RoidmiProtocol.java

app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/RoidmiSupport.java

## Diff:
```
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/devices/roidmi/RoidmiConst.java b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/devices/roidmi/RoidmiConst.java
index cc55564b7f..662f9f77e4 100644
--- a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/devices/roidmi/RoidmiConst.java
+++ b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/devices/roidmi/RoidmiConst.java
@@ -19,10 +19,6 @@ package nodomain.freeyourgadget.gadgetbridge.devices.roidmi;
 import android.graphics.Color;
 
 public class RoidmiConst {
-    public static final String ACTION_GET_LED_COLOR = "roidmi_get_led_color";
-    public static final String ACTION_GET_FM_FREQUENCY = "roidmi_get_frequency";
-    public static final String ACTION_GET_VOLTAGE = "roidmi_get_voltage";
-
     public static final int[] COLOR_PRESETS = new int[]{
             Color.rgb(0xFF, 0x00, 0x00), // red
             Color.rgb(0x00, 0xFF, 0x00), // green
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/Roidmi1Protocol.java b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/Roidmi1Protocol.java
index 44d49bf086..1cd838ccc5 100644
--- a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/Roidmi1Protocol.java
+++ b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/Roidmi1Protocol.java
@@ -26,6 +26,7 @@ import nodomain.freeyourgadget.gadgetbridge.devices.roidmi.RoidmiConst;
 import nodomain.freeyourgadget.gadgetbridge.impl.GBDevice;
 import nodomain.freeyourgadget.gadgetbridge.util.GB;
 
+@SuppressWarnings("unused")
 public class Roidmi1Protocol extends RoidmiProtocol {
     private static final Logger LOG = LoggerFactory.getLogger(Roidmi1Protocol.class);
 
@@ -58,43 +59,43 @@ public class Roidmi1Protocol extends RoidmiProtocol {
     @Override
     public GBDeviceEvent[] decodeResponse(final byte[] responseData) {
         if (responseData.length <= PACKET_MIN_LENGTH) {
-            LOG.info("Response too small");
+            LOG.warn("Response too small");
             return null;
         }
 
         for (int i = 0; i < packetHeader().length; i++) {
             if (responseData[i] != packetHeader()[i]) {
-                LOG.info("Invalid response header");
+                LOG.warn("Invalid response header");
                 return null;
             }
         }
 
         for (int i = 0; i < packetTrailer().length; i++) {
             if (responseData[responseData.length - packetTrailer().length + i] != packetTrailer()[i]) {
-                LOG.info("Invalid response trailer");
+                LOG.warn("Invalid response trailer");
                 return null;
             }
         }
 
         if (calcChecksum(responseData) != responseData[responseData.length - packetTrailer().length - 1]) {
-            LOG.info("Invalid response checksum");
+            LOG.warn("Invalid response checksum");
             return null;
         }
 
         switch (responseData[3]) {
             case COMMAND_GET_COLOR:
                 final int color = responseData[5];
-                LOG.debug("Got color: " + color);
+                LOG.debug("Got color: {}", color);
                 final GBDeviceEventLEDColor evColor = new GBDeviceEventLEDColor(RoidmiConst.COLOR_PRESETS[color - 1]);
                 return new GBDeviceEvent[]{evColor};
             case COMMAND_GET_FREQUENCY:
                 final String frequencyHex = GB.hexdump(responseData, 4, 2);
                 final float frequency = Float.parseFloat(frequencyHex) / 10.0f;
-                LOG.debug("Got frequency: " + frequency);
+                LOG.debug("Got frequency: {}", frequency);
                 final GBDeviceEventFmFrequency evFrequency = new GBDeviceEventFmFrequency(frequency);
                 return new GBDeviceEvent[]{evFrequency};
             default:
-                LOG.error("Unrecognized response type 0x" + GB.hexdump(responseData, packetHeader().length, 1));
+                LOG.error("Unrecognized response type 0x{}", GB.hexdump(responseData, packetHeader().length, 1));
                 return null;
         }
     }
@@ -141,6 +142,11 @@ public class Roidmi1Protocol extends RoidmiProtocol {
         return null;
     }
 
+    @Override
+    public int minPacketLength() {
+        return PACKET_MIN_LENGTH;
+    }
+
     @Override
     public byte[] packetHeader() {
         return PACKET_HEADER;
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/Roidmi3Protocol.java b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/Roidmi3Protocol.java
index ab449ef5c2..81e9ffe6d1 100644
--- a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/Roidmi3Protocol.java
+++ b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/Roidmi3Protocol.java
@@ -55,47 +55,47 @@ public class Roidmi3Protocol extends RoidmiProtocol {
     @Override
     public GBDeviceEvent[] decodeResponse(byte[] res) {
         if (res.length <= PACKET_MIN_LENGTH) {
-            LOG.info("Response too small");
+            LOG.warn("Response too small");
             return null;
         }
 
         if (calcChecksum(res) != res[res.length - 1]) {
-            LOG.info("Invalid response checksum");
+            LOG.warn("Invalid response checksum");
             return null;
         }
 
         if (res[0] + 2 != res.length) {
-            LOG.info("Packet length doesn't match");
+            LOG.warn("Packet length doesn't match");
             return null;
         }
 
         if (res[2] != (byte) 0x81) {
-            LOG.warn("Potentially unsupported response: " + GB.hexdump(res, 0, res.length));
+            LOG.warn("Potentially unsupported response: {}", GB.hexdump(res, 0, res.length));
         }
 
         switch(res[1]) {
             case RESPONSE_VOLTAGE:
                 final String voltageHex = GB.hexdump(res, 3, 2);
                 final float voltage = Float.parseFloat(voltageHex) / 100.0f;
-                LOG.debug("Got voltage: " + voltage);
+                LOG.debug("Got voltage: {}", voltage);
                 GBDeviceEventBatteryInfo evBattery = new GBDeviceEventBatteryInfo();
                 evBattery.state = BatteryState.NO_BATTERY;
                 evBattery.level = GBDevice.BATTERY_UNKNOWN;
                 evBattery.voltage = voltage;
                 return new GBDeviceEvent[]{evBattery};
             case RESPONSE_COLOR:
-                LOG.debug("Got color: #" + GB.hexdump(res, 3, 3));
+                LOG.debug("Got color: #{}", GB.hexdump(res, 3, 3));
                 final int color = 0xFF000000 | ((res[3] << 16) & 0xFF0000) | ((res[4] << 8) & 0xFF00) | (res[5] & 0xFF);
                 final GBDeviceEventLEDColor evColor = new GBDeviceEventLEDColor(color);
                 return new GBDeviceEvent[]{evColor};
             case RESPONSE_FREQUENCY:
                 final String frequencyHex = GB.hexdump(res, 3, 2);
                 final float frequency = Float.parseFloat(frequencyHex) / 10.0f;
-                LOG.debug("Got frequency: " + frequency);
+                LOG.debug("Got frequency: {}", frequency);
                 final GBDeviceEventFmFrequency evFrequency = new GBDeviceEventFmFrequency(frequency);
                 return new GBDeviceEvent[]{evFrequency};
             default:
-                LOG.error("Unrecognized response: " + GB.hexdump(res, 0, res.length));
+                LOG.error("Unrecognized response: {}", GB.hexdump(res, 0, res.length));
         }
 
         return null;
@@ -135,6 +135,11 @@ public class Roidmi3Protocol extends RoidmiProtocol {
         return encodeCommand(COMMAND_GET_FREQUENCY);
     }
 
+    @Override
+    public int minPacketLength() {
+        return PACKET_MIN_LENGTH;
+    }
+
     @Override
     public byte[] packetHeader() {
         return new byte[0];
@@ -150,6 +155,11 @@ public class Roidmi3Protocol extends RoidmiProtocol {
         return encodeCommand(COMMAND_GET_VOLTAGE);
     }
 
+    @Override
+    public boolean supportsBatteryVoltage() {
+        return true;
+    }
+
     public byte[] encodeDenoise(final boolean enabled) {
         final byte[] cmd = enabled ? COMMAND_DENOISE_ON : COMMAND_DENOISE_OFF;
         return encodeCommand(cmd);
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/RoidmiIoThread.java b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/RoidmiIoThread.java
deleted file mode 100644
index 4d3671e8aa..0000000000
--- a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/RoidmiIoThread.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*  Copyright (C) 2018-2024 JosÃ© Rebelo
-
-    This file is part of Gadgetbridge.
-
-    Gadgetbridge is free software: you can redistribute it and/or modify
-    it under the terms of the GNU Affero General Public License as published
-    by the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    Gadgetbridge is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU Affero General Public License for more details.
-
-    You should have received a copy of the GNU Affero General Public License
-    along with this program.  If not, see <https://www.gnu.org/licenses/>. */
-package nodomain.freeyourgadget.gadgetbridge.service.devices.roidmi;
-
-import android.bluetooth.BluetoothAdapter;
-import android.content.Context;
-
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-import nodomain.freeyourgadget.gadgetbridge.impl.GBDevice;
-import nodomain.freeyourgadget.gadgetbridge.service.btclassic.BtClassicIoThread;
-import nodomain.freeyourgadget.gadgetbridge.util.GB;
-
-public class RoidmiIoThread extends BtClassicIoThread {
-    private static final Logger LOG = LoggerFactory.getLogger(RoidmiIoThread.class);
-
-    private final byte[] HEADER;
-    private final byte[] TRAILER;
-
-    public RoidmiIoThread(GBDevice gbDevice, Context context, RoidmiProtocol roidmiProtocol, RoidmiSupport roidmiSupport, BluetoothAdapter roidmiBtAdapter) {
-        super(gbDevice, context, roidmiProtocol, roidmiSupport, roidmiBtAdapter);
-
-        HEADER = roidmiProtocol.packetHeader();
-        TRAILER = roidmiProtocol.packetTrailer();
-    }
-
-    @Override
-    protected byte[] parseIncoming(InputStream inputStream) throws IOException {
-        final ByteArrayOutputStream msgStream = new ByteArrayOutputStream();
-
-        boolean finished = false;
-        final byte[] incoming = new byte[1];
-
-        while (!finished) {
-            inputStream.read(incoming);
-            msgStream.write(incoming);
-
-            final byte[] arr = msgStream.toByteArray();
-            if (arr.length > HEADER.length) {
-                int expectedLength = HEADER.length + TRAILER.length + arr[HEADER.length] + 2;
-                if (arr.length == expectedLength) {
-                    finished = true;
-                }
-            }
-        }
-
-        final byte[] msgArray = msgStream.toByteArray();
-        LOG.debug("Packet: " + GB.hexdump(msgArray, 0, msgArray.length));
-        return msgArray;
-    }
-}
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/RoidmiProtocol.java b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/RoidmiProtocol.java
index 27867c8950..7c2c369489 100644
--- a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/RoidmiProtocol.java
+++ b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/RoidmiProtocol.java
@@ -47,8 +47,14 @@ public abstract class RoidmiProtocol extends GBDeviceProtocol {
 
     public abstract byte[] encodeGetFmFrequency();
 
+    public boolean supportsBatteryVoltage() {
+        return false;
+    }
+
     public abstract byte[] encodeGetVoltage();
 
+    public abstract int minPacketLength();
+
     public abstract byte[] packetHeader();
 
     public abstract byte[] packetTrailer();
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/RoidmiSupport.java b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/RoidmiSupport.java
index a3080dac22..7d11d4f31a 100644
--- a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/RoidmiSupport.java
+++ b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/roidmi/RoidmiSupport.java
@@ -22,55 +22,60 @@ import android.os.Handler;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import nodomain.freeyourgadget.gadgetbridge.devices.roidmi.RoidmiConst;
-import nodomain.freeyourgadget.gadgetbridge.model.DeviceType;
-import nodomain.freeyourgadget.gadgetbridge.service.serial.AbstractSerialDeviceSupport;
-import nodomain.freeyourgadget.gadgetbridge.service.serial.GBDeviceIoThread;
-import nodomain.freeyourgadget.gadgetbridge.service.serial.GBDeviceProtocol;
+import java.nio.ByteBuffer;
 
-public class RoidmiSupport extends AbstractSerialDeviceSupport {
+import nodomain.freeyourgadget.gadgetbridge.impl.GBDevice;
+import nodomain.freeyourgadget.gadgetbridge.model.DeviceType;
+import nodomain.freeyourgadget.gadgetbridge.service.btbr.TransactionBuilder;
+import nodomain.freeyourgadget.gadgetbridge.service.serial.AbstractHeadphoneSerialDeviceSupportV2;
+import nodomain.freeyourgadget.gadgetbridge.util.ArrayUtils;
+import nodomain.freeyourgadget.gadgetbridge.util.GB;
+
+public class RoidmiSupport extends AbstractHeadphoneSerialDeviceSupportV2<RoidmiProtocol> {
     private static final Logger LOG = LoggerFactory.getLogger(RoidmiSupport.class);
 
     private final Handler handler = new Handler();
+
+    private final ByteBuffer packetBuffer = ByteBuffer.allocate(2048);
+
     private int infoRequestTries = 0;
-    private final Runnable infosRunnable = new Runnable() {
-        @Override
-        public void run() {
-            infoRequestTries += 1;
+    private final Runnable infosRunnable = () -> {
+        infoRequestTries += 1;
 
-            try {
-                boolean infoMissing = false;
+        boolean infoMissing = false;
 
-                if (getDevice().getExtraInfo("led_color") == null) {
-                    infoMissing = true;
-                    onSendConfiguration(RoidmiConst.ACTION_GET_LED_COLOR);
-                }
+        final TransactionBuilder builder = createTransactionBuilder("request missing infos");
 
-                if (getDevice().getExtraInfo("fm_frequency") == null) {
-                    infoMissing = true;
+        if (getDevice().getExtraInfo("led_color") == null) {
+            infoMissing = true;
+            builder.write(mDeviceProtocol.encodeGetLedColor());
+        }
 
-                    onSendConfiguration(RoidmiConst.ACTION_GET_FM_FREQUENCY);
-                }
+        if (getDevice().getExtraInfo("fm_frequency") == null) {
+            infoMissing = true;
 
-                if (getDevice().getType() == DeviceType.ROIDMI3) {
-                    if (getDevice().getBatteryVoltage() == -1) {
-                        infoMissing = true;
+            builder.write(mDeviceProtocol.encodeGetFmFrequency());
+        }
 
-                        onSendConfiguration(RoidmiConst.ACTION_GET_VOLTAGE);
-                    }
-                }
+        if (mDeviceProtocol.supportsBatteryVoltage()) {
+            if (getDevice().getBatteryVoltage() == -1) {
+                infoMissing = true;
 
-                if (infoMissing) {
-                    if (infoRequestTries < 6) {
-                        requestDeviceInfos(500 + infoRequestTries * 120);
-                    } else {
-                        LOG.error("Failed to get Roidmi infos after 6 tries");
-                    }
-                }
-            } catch (final Exception e) {
-                LOG.error("Failed to get Roidmi infos", e);
+                builder.write(mDeviceProtocol.encodeGetVoltage());
             }
         }
+
+        if (infoMissing) {
+            if (infoRequestTries < 6) {
+                builder.queue();
+                requestDeviceInfos(500 + infoRequestTries * 120);
+            } else {
+                LOG.error("Failed to get Roidmi infos after 6 tries");
+            }
+        } else {
+            builder.setDeviceState(GBDevice.State.INITIALIZED);
+            builder.queue();
+        }
     };
 
     private void requestDeviceInfos(int delayMillis) {
@@ -78,22 +83,31 @@ public class RoidmiSupport extends AbstractSerialDeviceSupport {
     }
 
     @Override
-    public boolean connect() {
+    protected TransactionBuilder initializeDevice(final TransactionBuilder builder) {
+        packetBuffer.clear();
+        getDevice().setFirmwareVersion("N/A");
+        builder.write(mDeviceProtocol.encodeGetLedColor());
+        builder.write(mDeviceProtocol.encodeGetFmFrequency());
+        if (mDeviceProtocol.supportsBatteryVoltage()) {
+            builder.write(mDeviceProtocol.encodeGetVoltage());
+        }
+        requestDeviceInfos(1500);
+        return builder;
+    }
+
+    @Override
+    public void dispose() {
         synchronized (ConnectionMonitor) {
-            final RoidmiIoThread deviceIOThread = getDeviceIOThread();
-            if (!deviceIOThread.isAlive()) {
-                deviceIOThread.start();
-                requestDeviceInfos(1500);
-            }
-            return true;
+            handler.removeCallbacksAndMessages(null);
+            super.dispose();
         }
     }
 
     @Override
-    protected GBDeviceProtocol createDeviceProtocol() {
+    protected RoidmiProtocol createDeviceProtocol() {
         final DeviceType deviceType = getDevice().getType();
 
-        switch(deviceType) {
+        switch (deviceType) {
             case ROIDMI:
                 return new Roidmi1Protocol(getDevice());
             case ROIDMI3:
@@ -106,40 +120,55 @@ public class RoidmiSupport extends AbstractSerialDeviceSupport {
     }
 
     @Override
-    public void onSendConfiguration(final String config) {
-        LOG.debug("onSendConfiguration {}", config);
+    public void onSocketRead(final byte[] data) {
+        packetBuffer.put(data);
+        packetBuffer.flip();
 
-        final RoidmiIoThread roidmiIoThread = getDeviceIOThread();
-        final RoidmiProtocol roidmiProtocol = (RoidmiProtocol) getDeviceProtocol();
+        while (packetBuffer.hasRemaining()) {
+            final int start = packetBuffer.position();
+            packetBuffer.mark();
 
-        switch (config) {
-            case RoidmiConst.ACTION_GET_LED_COLOR:
-                roidmiIoThread.write(roidmiProtocol.encodeGetLedColor());
+            if (packetBuffer.remaining() < mDeviceProtocol.minPacketLength()) {
+                // not enough bytes for min packet
+                packetBuffer.reset();
                 break;
-            case RoidmiConst.ACTION_GET_FM_FREQUENCY:
-                roidmiIoThread.write(roidmiProtocol.encodeGetFmFrequency());
-                break;
-            case RoidmiConst.ACTION_GET_VOLTAGE:
-                roidmiIoThread.write(roidmiProtocol.encodeGetVoltage());
-                break;
-            default:
-                LOG.error("Invalid Roidmi configuration {}", config);
+            }
+
+            final byte[] expectedHeader = mDeviceProtocol.packetHeader();
+            if (expectedHeader.length > 0) {
+                final byte[] header = new byte[expectedHeader.length];
+                packetBuffer.get(header);
+                if (!ArrayUtils.equals(header, expectedHeader, 0)) {
+                    LOG.warn("Unexpected header {}", GB.hexdump(header));
+                    // Skip 1 byte
+                    packetBuffer.reset();
+                    packetBuffer.position(packetBuffer.position() + 1);
+                    continue;
+                }
+            }
+
+            final int payloadLength = packetBuffer.get() & 0xff;
+
+            final byte[] expectedTrailer = mDeviceProtocol.packetTrailer();
+            if (packetBuffer.remaining() < payloadLength + 1 + expectedTrailer.length) {
+                // not enough bytes
+                packetBuffer.reset();
                 break;
+            }
+
+            // header + payload length + payload + checksum + trailer
+            final byte[] packet = new byte[expectedHeader.length + 1 + payloadLength + 1 + expectedTrailer.length];
+            packetBuffer.position(start);
+            packetBuffer.get(packet);
+
+            // Handle it upstream, to the protocol
+            try {
+                super.onSocketRead(packet);
+            } catch (final Exception e) {
+                LOG.error("Failed to handle command", e);
+            }
         }
-    }
 
-    @Override
-    protected GBDeviceIoThread createDeviceIOThread() {
-        return new RoidmiIoThread(getDevice(), getContext(), (RoidmiProtocol) getDeviceProtocol(), RoidmiSupport.this, getBluetoothAdapter());
-    }
-
-    @Override
-    public synchronized RoidmiIoThread getDeviceIOThread() {
-        return (RoidmiIoThread) super.getDeviceIOThread();
-    }
-
-    @Override
-    public boolean useAutoConnect() {
-        return false;
+        packetBuffer.compact();
     }
 }
```
-----------------------------------
