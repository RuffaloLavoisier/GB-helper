# Commit: 4c65009f9cdaa955c6e93b50c5d37e7f73474948
## Message: Zepp OS: Add experimental support for weather v5
## Changed files:
app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/huami/zeppos/services/http/ZeppOsWeatherHandlerV5.kt

app/src/main/java/nodomain/freeyourgadget/gadgetbridge/util/gson/OffsetDateTimeAdapter.kt

app/src/main/java/nodomain/freeyourgadget/gadgetbridge/model/WeatherSpec.kt

app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/huami/zeppos/services/ZeppOsHttpService.java

app/src/main/res/xml/devicesettings_zeppos_experimental.xml

## Diff:
```
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/model/WeatherSpec.kt b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/model/WeatherSpec.kt
index a430248c92..c9d5945db9 100644
--- a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/model/WeatherSpec.kt
+++ b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/model/WeatherSpec.kt
@@ -21,6 +21,12 @@ package nodomain.freeyourgadget.gadgetbridge.model
 import android.location.Location
 import android.os.Parcel
 import android.os.Parcelable
+import net.e175.klaus.solarpositioning.DeltaT
+import net.e175.klaus.solarpositioning.SPA
+import net.e175.klaus.solarpositioning.SunriseTransitSet
+import java.util.Date
+import java.util.GregorianCalendar
+import kotlin.math.floor
 
 // FIXME: document me and my fields, including units
 /**
@@ -487,6 +493,10 @@ class WeatherSpec() : Parcelable {
             return toBeaufort(this.windSpeed)
         }
 
+        fun lunarDay(): Int {
+            return toLunarDay(moonPhase.toDouble())
+        }
+
         override fun equals(other: Any?): Boolean {
             if (this === other) return true
             if (javaClass != other?.javaClass) return false
@@ -644,6 +654,45 @@ class WeatherSpec() : Parcelable {
             return level
         }
 
+        fun toLunarDay(phaseDegrees: Double): Int {
+            val synodicMonth = 29.53059
+            val normalized = ((phaseDegrees % 360) + 360) % 360
+            return floor((normalized / 360.0) * synodicMonth).toInt() + 1
+        }
+
+        fun sunriseTransitSet(date: GregorianCalendar, location: Location): SunriseTransitSet {
+            return SPA.calculateSunriseTransitSet(
+                date.toZonedDateTime(),
+                location.latitude,
+                location.longitude,
+                DeltaT.estimate(date.toZonedDateTime().toLocalDate())
+            )
+        }
+
+        fun sunriseComputed(sunRise: Int, date: GregorianCalendar, location: Location?): Date? {
+            if (sunRise > 0) {
+                return Date(sunRise * 1000L)
+            }
+            if (location == null) {
+                return null
+            }
+            return sunriseTransitSet(date, location).sunrise?.let {
+                return Date.from(it.toInstant())
+            }
+        }
+
+        fun sunsetComputed(sunSet: Int, date: GregorianCalendar, location: Location?): Date? {
+            if (sunSet > 0) {
+                return Date(sunSet * 1000L)
+            }
+            if (location == null) {
+                return null
+            }
+            return sunriseTransitSet(date, location).sunset?.let {
+                return Date.from(it.toInstant())
+            }
+        }
+
         fun createTestWeather(): WeatherSpec {
             val weather = WeatherSpec()
 
@@ -668,8 +717,11 @@ class WeatherSpec() : Parcelable {
             weather.currentHumidity = 30
 
             weather.hourly = ArrayList()
+            var hourlyTimestamp = weather.timestamp + 3600
+
             for (i in 0..23) {
                 val gbForecast = Hourly()
+                gbForecast.timestamp = hourlyTimestamp
                 gbForecast.temp = 10 + i + 273
                 gbForecast.conditionCode = 800 // clear
                 gbForecast.precipProbability = 50 + i
@@ -679,6 +731,8 @@ class WeatherSpec() : Parcelable {
                 gbForecast.uvIndex = 2f + i
 
                 weather.hourly.add(gbForecast)
+
+                hourlyTimestamp += 3600
             }
 
             weather.forecasts = ArrayList()
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/huami/zeppos/services/ZeppOsHttpService.java b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/huami/zeppos/services/ZeppOsHttpService.java
index ecdaa0d4e0..3a36ae7907 100644
--- a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/huami/zeppos/services/ZeppOsHttpService.java
+++ b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/huami/zeppos/services/ZeppOsHttpService.java
@@ -39,6 +39,7 @@ import nodomain.freeyourgadget.gadgetbridge.service.devices.huami.zeppos.ZeppOsT
 import nodomain.freeyourgadget.gadgetbridge.service.devices.huami.zeppos.ZeppOsWeatherHandler;
 import nodomain.freeyourgadget.gadgetbridge.service.devices.huami.zeppos.AbstractZeppOsService;
 import nodomain.freeyourgadget.gadgetbridge.service.devices.huami.zeppos.services.http.HttpAppsSettingsHandler;
+import nodomain.freeyourgadget.gadgetbridge.service.devices.huami.zeppos.services.http.ZeppOsWeatherHandlerV5;
 import nodomain.freeyourgadget.gadgetbridge.util.FileUtils;
 import nodomain.freeyourgadget.gadgetbridge.util.HttpUtils;
 import nodomain.freeyourgadget.gadgetbridge.util.StringUtils;
@@ -157,25 +158,45 @@ public class ZeppOsHttpService extends AbstractZeppOsService {
         final String path = url.getPath();
         final Map<String, String> query = HttpUtils.urlQueryParameters(url);
 
-        if (path.startsWith("/weather/")) {
-            if (weatherHandler != null) {
-                final ZeppOsWeatherHandler.Response response = weatherHandler.handleHttpRequest(path, query);
-                replySimpleHttpSuccess(requestId, response.getHttpStatusCode(), response.toJson());
-                return;
-            }
+        final int statusCode;
+        final String response;
 
-            LOG.error("Weather handler is null");
-        } else if (host.equals("api-mifit.huami.com") && path.startsWith("/apps/")) {
-            final String response = HttpAppsSettingsHandler.handleHttpRequest(path, query);
-            if (response != null) {
-                replySimpleHttpSuccess(requestId, 200, response);
+        if (path.startsWith("/weather/")) {
+            if (path.startsWith("/weather/v5/")) {
+                statusCode = 200;
+                final boolean experimentalWeatherV5 = getSupport().getCoordinator().experimentalSettingEnabled(
+                        getSupport().getDevice(),
+                        "zepp_os_experimental_weather_v5"
+                );
+                if (experimentalWeatherV5) {
+                    response = ZeppOsWeatherHandlerV5.handleHttpRequest(path, query);
+                } else {
+                    LOG.warn("Experimental weather v5 is disabled, ignoring request");
+                    response = null;
+                }
+            } else if (weatherHandler != null) {
+                final ZeppOsWeatherHandler.Response weatherResponse = weatherHandler.handleHttpRequest(path, query);
+                statusCode = weatherResponse.getHttpStatusCode();
+                response = weatherResponse.toJson();
             } else {
-                replyHttpNoInternet(requestId);
+                LOG.error("Weather handler is null");
+                statusCode = 0;
+                response = null;
             }
+        } else if (host.equals("api-mifit.huami.com") && path.startsWith("/apps/")) {
+            statusCode = 200;
+            response = HttpAppsSettingsHandler.handleHttpRequest(path, query);
+        } else {
+            LOG.error("Unhandled simple request URL {}", url);
+            statusCode = 0;
+            response = null;
         }
 
-        LOG.error("Unhandled simple request URL {}", url);
-        replyHttpNoInternet(requestId);
+        if (response != null) {
+            replySimpleHttpSuccess(requestId, statusCode, response);
+        } else {
+            replyHttpNoInternet(requestId);
+        }
     }
 
     private void handleRawDownloadRequest(final int requestId, final String urlString) {
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/huami/zeppos/services/http/ZeppOsWeatherHandlerV5.kt b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/huami/zeppos/services/http/ZeppOsWeatherHandlerV5.kt
new file mode 100644
index 0000000000..4159109e7c
--- /dev/null
+++ b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/service/devices/huami/zeppos/services/http/ZeppOsWeatherHandlerV5.kt
@@ -0,0 +1,341 @@
+package nodomain.freeyourgadget.gadgetbridge.service.devices.huami.zeppos.services.http
+
+import com.google.gson.Gson
+import com.google.gson.GsonBuilder
+import com.google.gson.JsonObject
+import nodomain.freeyourgadget.gadgetbridge.model.WeatherSpec
+import nodomain.freeyourgadget.gadgetbridge.model.weather.Weather.getWeatherSpec
+import nodomain.freeyourgadget.gadgetbridge.service.devices.huami.zeppos.ZeppOsWeatherHandler
+import nodomain.freeyourgadget.gadgetbridge.util.DateTimeUtils
+import nodomain.freeyourgadget.gadgetbridge.util.gson.OffsetDateTimeAdapter
+import org.slf4j.Logger
+import org.slf4j.LoggerFactory
+import java.time.Instant
+import java.time.OffsetDateTime
+import java.time.ZoneId
+import java.util.Date
+import java.util.GregorianCalendar
+import kotlin.math.roundToInt
+
+@Suppress("unused")
+object ZeppOsWeatherHandlerV5 {
+    private val LOG: Logger = LoggerFactory.getLogger(ZeppOsWeatherHandlerV5::class.java)
+
+    private val GSON: Gson = GsonBuilder()
+        .serializeNulls()
+        .registerTypeAdapter(OffsetDateTime::class.java, OffsetDateTimeAdapter())
+        .create()
+
+    @JvmStatic
+    fun handleHttpRequest(path: String, query: MutableMap<String, String>): String? {
+        val weatherSpec = getWeatherSpec()
+
+        if (weatherSpec == null) {
+            LOG.error("No weather in weather instance")
+            return null
+        }
+
+        // /weather/v5/<LOCALE>/<LONGITUDE>/<LATITUDE>/
+        if (!Regex("^/weather/v5/[^/]+/[^/]+/[^/]+/?$").matches(path)) {
+            LOG.error("Unknown path: {}", path)
+            return null
+        }
+
+        val pathParts = path.trim('/').split("/")
+        val locale = pathParts[2]
+        val longitude = pathParts[3]
+        val latitude = pathParts[4]
+
+        LOG.debug("Weather request: locale={}, lon={}, lat={}", locale, longitude, latitude)
+
+        val datasetsParam = query["datasets"]
+        if (datasetsParam.isNullOrBlank()) {
+            LOG.error("No datasets parameter provided")
+            return null
+        }
+
+        val datasets = datasetsParam.split(",").map { it.trim() }
+
+        val response = JsonObject()
+
+        for (dataset in datasets) {
+            val datasetObject = when (dataset) {
+                "place" -> createPlace(weatherSpec)
+                "hourlyWeather" -> createHourlyWeather(weatherSpec)
+                "hourlyAirQuality" -> createHourlyAirQuality(weatherSpec)
+                "dailyIndices" -> createDailyIndices(weatherSpec)
+                "dailyWeather" -> createDailyWeather(weatherSpec)
+                "dailyTide" -> createDailyTide(weatherSpec)
+                // TODO "dailyAirQuality" -> createDailyAirQuality(weatherSpec)
+                else -> null
+            }
+
+            if (datasetObject != null) {
+                response.add(dataset, GSON.toJsonTree(datasetObject))
+            } else {
+                LOG.warn("Failed to compute dataset object for {}", dataset)
+            }
+        }
+
+        return GSON.toJson(response)
+    }
+
+    private fun createMetadata(weatherSpec: WeatherSpec) = Metadata(
+        reportedTime = toOffsetDateTime(Date(weatherSpec.timestamp * 1000L)),
+        units = "m",
+        version = 1,
+    )
+
+    private fun createPlace(weatherSpec: WeatherSpec) = Place(
+        locationKey = "accu:123456",
+        longitude = weatherSpec.longitude.toString(),
+        latitude = weatherSpec.latitude.toString(),
+        affiliation = weatherSpec.location,
+        name = weatherSpec.location,
+        countryCode = null,
+    )
+
+    private fun createHourlyWeather(weatherSpec: WeatherSpec): HourlyWeather {
+        return HourlyWeather(
+            metadata = createMetadata(weatherSpec),
+            hours = weatherSpec.hourly
+                .filter { it.timestamp != 0 }
+                .map {
+                    HourlyWeatherHour(
+                        forecastStart = toOffsetDateTime(Date(it.timestamp * 1000L)),
+                        conditionCode = ZeppOsWeatherHandler.mapToZeppOsWeatherCode(it.conditionCode).toString(),
+                        humidity = it.humidity / 100.0f,
+                        pressure = weatherSpec.pressure, // TODO WeatherSpec does not support hourly pressure
+                        temperature = it.temp - 273.15f,
+                        uvIndex = it.uvIndex.roundToInt(),
+                        visibility = weatherSpec.visibility, // TODO WeatherSpec does not support hourly visibility
+                        windDirection = it.windDirection,
+                        windSpeed = it.windSpeed,
+                        windScale = it.windSpeedAsBeaufort(),
+                    )
+                }.toList()
+        )
+    }
+
+    private fun createHourlyAirQuality(weatherSpec: WeatherSpec): HourlyAirQuality {
+        // TODO WeatherSpec does not support hourly air quality
+        return HourlyAirQuality(
+            metadata = createMetadata(weatherSpec),
+            hours = emptyList()
+        )
+    }
+
+    private fun createDailyIndices(weatherSpec: WeatherSpec): DailyIndices {
+        return DailyIndices(
+            metadata = createMetadata(weatherSpec),
+            days = (listOf(weatherSpec.todayAsDaily()) + weatherSpec.forecasts).mapIndexed { i, day ->
+                val dayTimestamp = weatherSpec.timestamp * 1000L + i * 86400_000L
+                return@mapIndexed DailyIndicesDay(
+                    forecastStart = toOffsetDateTime(DateTimeUtils.dayStart(Date(dayTimestamp))),
+                    forecastEnd = toOffsetDateTime(DateTimeUtils.dayEnd(Date(dayTimestamp))),
+                    outdoorSportIndex = null,
+                    uvLevel = day.uvIndex.roundToInt().toString(),
+                    carWashingIndex = null,
+                    fishingIndex = null,
+                    allergyIndex = null
+                )
+            }.toList()
+        )
+    }
+
+    private fun createDailyWeather(weatherSpec: WeatherSpec): DailyWeather {
+        return DailyWeather(
+            metadata = createMetadata(weatherSpec),
+            days = (listOf(weatherSpec.todayAsDaily()) + weatherSpec.forecasts).mapIndexed { i, day ->
+                val dayTimestamp = weatherSpec.timestamp * 1000L + i * 86400_000L
+                val calendar = GregorianCalendar()
+                calendar.setTime(Date(dayTimestamp))
+
+                val sunrise = WeatherSpec.sunriseComputed(day.sunRise, calendar, weatherSpec.getLocationObject())
+                val sunset = WeatherSpec.sunsetComputed(day.sunRise, calendar, weatherSpec.getLocationObject())
+
+                DailyWeatherDay(
+                    forecastStart = toOffsetDateTime(DateTimeUtils.dayStart(Date(dayTimestamp))),
+                    forecastEnd = toOffsetDateTime(DateTimeUtils.dayEnd(Date(dayTimestamp))),
+                    conditionCode = ZeppOsWeatherHandler.mapToZeppOsWeatherCode(day.conditionCode).toString(),
+                    maxUvIndex = day.uvIndex.roundToInt(),
+                    moonPhaseLunarDay = day.lunarDay().toString(),
+                    moonPhase = getMoonPhaseString(day.lunarDay()),
+                    moonrise = if (day.moonRise > 0) toOffsetDateTime(Date(day.moonRise * 1000L)) else null,
+                    moonset = if (day.moonSet > 0) toOffsetDateTime(Date(day.moonSet * 1000L)) else null,
+                    sunrise = sunrise?.let { toOffsetDateTime(it) },
+                    sunset = sunset?.let { toOffsetDateTime(it) },
+                    temperatureMax = day.maxTemp - 273.15f,
+                    temperatureMin = day.minTemp - 273.15f,
+                    daytimeForecast = null,
+                    overnightForecast = null,
+                    //daytimeForecast = DayPartForecast(
+                    //    forecastStart = sunrise,
+                    //    forecastEnd = sunset,
+                    //    conditionCode = ZeppOsWeatherHandler.mapToZeppOsWeatherCode(day.conditionCode).toString(),
+                    //    humidity = day.humidity / 100.0f,
+                    //    windDirection = day.windDirection,
+                    //    windSpeed = day.windSpeed,
+                    //    windScale = day.windSpeedAsBeaufort(),
+                    //),
+                    //overnightForecast = DayPartForecast(
+                    //    forecastStart = sunset,
+                    //    forecastEnd = Date(sunrise.time + 86400_000L),
+                    //    conditionCode = ZeppOsWeatherHandler.mapToZeppOsWeatherCode(day.conditionCode).toString(),
+                    //    humidity = day.humidity / 100.0f,
+                    //    windDirection = day.windDirection,
+                    //    windSpeed = day.windSpeed,
+                    //    windScale = day.windSpeedAsBeaufort(),
+                    //),
+                )
+            }
+        )
+    }
+
+    private fun toOffsetDateTime(date: Date): OffsetDateTime {
+        return OffsetDateTime.ofInstant(
+            Instant.ofEpochMilli(date.time),
+            ZoneId.systemDefault()
+        )
+    }
+
+    private fun createDailyTide(weatherSpec: WeatherSpec) = DailyTide(
+        // We do not support tide data
+        metadata = createMetadata(weatherSpec),
+        days = emptyList()
+    )
+
+    private fun getMoonPhaseString(moonPhase: Int): String = when (moonPhase) {
+        // TODO only seen waxingCrescent
+        0 -> "new"
+        in 1..6 -> "waxingCrescent"
+        7 -> "firstQuarter"
+        in 8..13 -> "waxingGibbous"
+        14 -> "full"
+        in 15..20 -> "waningGibbous"
+        21 -> "lastQuarter"
+        in 22..27 -> "waningCrescent"
+        else -> "new"
+    }
+
+    data class Metadata(
+        val reportedTime: OffsetDateTime,
+        val units: String,
+        val version: Int,
+    )
+
+    data class Place(
+        val locationKey: String?,
+        val longitude: String?,
+        val latitude: String?,
+        val affiliation: String?,
+        val name: String?,
+        val countryCode: String?,
+    )
+
+    data class HourlyWeatherHour(
+        val forecastStart: OffsetDateTime,
+        val conditionCode: String,
+        val humidity: Float,
+        val pressure: Float,
+        val temperature: Float,
+        val uvIndex: Int,
+        val visibility: Float,
+        val windDirection: Int,
+        val windSpeed: Float,
+        val windScale: Int,
+    )
+
+    data class HourlyWeather(
+        val metadata: Metadata,
+        val hours: List<HourlyWeatherHour>,
+    )
+
+    data class HourlyAirQualityHour(
+        val forecastStart: OffsetDateTime,
+        val aqi: String,
+        val co: String,
+        val no2: String,
+        val o3: String,
+        val pm10: String,
+        val pm25: String,
+        val so2: String,
+    )
+
+    data class HourlyAirQuality(
+        val metadata: Metadata,
+        val hours: List<HourlyAirQualityHour>,
+    )
+
+    data class DailyIndicesDay(
+        val forecastStart: OffsetDateTime,
+        val forecastEnd: OffsetDateTime,
+        val outdoorSportIndex: String?,
+        val uvLevel: String?,
+        val carWashingIndex: String?,
+        val fishingIndex: String?,
+        val allergyIndex: String?,
+    )
+
+    data class DailyIndices(
+        val metadata: Metadata,
+        val days: List<DailyIndicesDay>,
+    )
+
+    data class DayPartForecast(
+        val forecastStart: OffsetDateTime,
+        val forecastEnd: OffsetDateTime,
+        val conditionCode: String,
+        val humidity: Float,
+        val windDirection: Int,
+        val windSpeed: Float,
+        val windScale: Int,
+    )
+
+    data class DailyWeatherDay(
+        val forecastStart: OffsetDateTime,
+        val forecastEnd: OffsetDateTime,
+        val conditionCode: String,
+        val maxUvIndex: Int,
+        val moonPhaseLunarDay: String?,
+        val moonPhase: String?,
+        val moonrise: OffsetDateTime?,
+        val moonset: OffsetDateTime?,
+        val sunrise: OffsetDateTime?,
+        val sunset: OffsetDateTime?,
+        val temperatureMax: Float,
+        val temperatureMin: Float,
+        val daytimeForecast: DayPartForecast?,
+        val overnightForecast: DayPartForecast?,
+    )
+
+    data class DailyWeather(
+        val metadata: Metadata,
+        val days: List<DailyWeatherDay>,
+    )
+
+    data class TideTableEntry(
+        val forecastTime: OffsetDateTime,
+        val height: String,
+        val type: String,
+    )
+
+    data class TideHourlyEntry(
+        val forecastStart: OffsetDateTime,
+        val height: String,
+    )
+
+    data class DailyTideDay(
+        val forecastStart: OffsetDateTime,
+        val forecastEnd: OffsetDateTime,
+        val poiName: String,
+        val poiKey: String,
+        val tideTable: List<TideTableEntry>,
+        val tideHourly: List<TideHourlyEntry>,
+    )
+
+    data class DailyTide(
+        val metadata: Metadata,
+        val days: List<DailyTideDay>,
+    )
+}
diff --git a/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/util/gson/OffsetDateTimeAdapter.kt b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/util/gson/OffsetDateTimeAdapter.kt
new file mode 100644
index 0000000000..49133924ff
--- /dev/null
+++ b/app/src/main/java/nodomain/freeyourgadget/gadgetbridge/util/gson/OffsetDateTimeAdapter.kt
@@ -0,0 +1,33 @@
+package nodomain.freeyourgadget.gadgetbridge.util.gson
+
+import com.google.gson.TypeAdapter
+import com.google.gson.stream.JsonReader
+import com.google.gson.stream.JsonWriter
+import java.io.IOException
+import java.time.OffsetDateTime
+import java.time.format.DateTimeFormatter
+
+class OffsetDateTimeAdapter : TypeAdapter<OffsetDateTime?>() {
+    @Throws(IOException::class)
+    override fun write(out: JsonWriter, value: OffsetDateTime?) {
+        if (value == null) {
+            out.nullValue()
+        } else {
+            val formatted = value.format(FMT)
+            if (formatted.endsWith("Z")) {
+                out.value(formatted.dropLast(1) + "+00:00")
+            } else {
+                out.value(formatted)
+            }
+        }
+    }
+
+    @Throws(IOException::class)
+    override fun read(jsonReader: JsonReader): OffsetDateTime? {
+        return OffsetDateTime.parse(jsonReader.nextString(), FMT)
+    }
+
+    companion object {
+        private val FMT: DateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ssXXX")
+    }
+}
diff --git a/app/src/main/res/xml/devicesettings_zeppos_experimental.xml b/app/src/main/res/xml/devicesettings_zeppos_experimental.xml
index 477984d787..81d11ca011 100644
--- a/app/src/main/res/xml/devicesettings_zeppos_experimental.xml
+++ b/app/src/main/res/xml/devicesettings_zeppos_experimental.xml
@@ -15,4 +15,12 @@
         android:layout="@layout/preference_checkbox"
         android:summary="Enable Alexa / Zepp Flow manual debug options and voice receiving. Not yet functional."
         android:title="Assistant service" />
+
+    <SwitchPreferenceCompat
+        android:defaultValue="false"
+        android:icon="@drawable/ic_wb_sunny"
+        android:key="zepp_os_experimental_weather_v5"
+        android:layout="@layout/preference_checkbox"
+        android:summary="Not tested. See Codeberg issue #5653"
+        android:title="Weather v5" />
 </androidx.preference.PreferenceScreen>
```
-----------------------------------
